# 重新梳理插件化技术的整体思路



## 插件的工程化

插件化技术分为宿主 HostApp 和插件 Plugin1 这两个 apk，有时还会有 MyPluginLibrary，宿主和插件都要依赖它。



## 插件中类的加载

HostApp 想要加载 Plugin1 中的类，还使用 HostApp 的 ClassLoader 是不行的。由此产生了很多种解决方案：

1）最直接的做法就是，在反射插件中的类时使用 Plugin1.apk 对应的 ClassLoader。

2）无论是宿主还是插件，它们各自的 ClassLoader 都对应一个 dex 数组，把这些插件的 dex 数组都合并到宿主的 dex 数组中，那么宿主 App 就可以通过反射加载任何插件的任何类，而不需要切换到插件的 ClassLoader。

3）自定义一个 ClassLoader，取代原先宿主的 ClassLoader。同时在自定义的 ClassLoader 中，放一个集合，承载所有插件的 ClassLoader。那么这个自定义 ClassLoader 在加载任何一个类的时候，无论是插件还是宿主的类，都会先在宿主中寻找，如果没有，再遍历内部的 ClassLoader 集合，看哪个插件的 ClassLoader 能加载这个类。



## 哪些地方可以 Hook

Hook 可分为三类：

1）在 App 中使用的类，可以 Hook。

Android 系统源码中的大部分类和方法都标记为 hide，对于 App 开发人员不可见。我们可以通过反射去使用它们，而不能 Hook 它们。但是 Android 系统源码中也有一些类，在 App 中也能使用，比较典型的代表是 Instrumentation 和 Callback，我们可以创建一个继承自 Instrumentation 的类，且称其为 EvilInstrumentation，然后用这个 EvilInstrumentation 类的对象替换掉 Android 系统中原先的那个 Instrumentation 对象。

2）实现了接口的类。

虽然 Android 系统源码中的大部分类和方法都标记为 hide，但只要这个类实现了一个接口，我们就可以借助 Proxy.newProxyInstance 方法去截获它的方法。比较典型的代码是 IActivityManager 接口，以及实现这个接口的 AMN，还有一个是 IPackageManager 接口。

3）集合。

我们虽然没有办法 Hook 一个标记为 hide 的类，但是当我们发现 Android 源码中的某个类拥有集合变量的时候，我们就可以通过反射构造出一个对象，然后还是通过反射添加到这个集合中。比较典型的案例是，为插件创建一个 LoadedApk 对象，并把它事先放到 mPackages 缓存中，这样就能直接命中缓存。



## Activity 插件化的解决方案

Activity 的插件化解决方案，从大方向上分为动态替换和静态代理两种。

1）动态替换。这是一种“占位”的思想。HostApp 中声明一个用于占位的 StubActivity。启动插件中的 ActivityA，但是告诉 AMS 启动的是 StubActivity，欺骗成功后，在即将启动 Activity 时，再把 StubActivity 改为 ActivityA。为此需要 Hook Android 系统中的一些方法。

2）静态代理。这是一种牵线木偶的思想，在 HostApp 中设计一个 ProxyActivity，由它来决定要启动插件中的哪个 Activity。插件中的 Activity 都是没有生命的，所以在 ProxyActivity 的生命周期函数中，调用插件 Activity 相应的生命周期函数。

此外，Activity 的插件化，还需要解决 LaunchMode 的问题。



## 资源的解决方案

千言万语聊资源，其实只有一句话重要：资源主要为 Activity 服务。

App 是通过 AssetManager 来加载资源的，它通过 addAssetPath 方法加载指定位置的资源。默认是加载 App 自身的资源。

从 HostApp 跳转到 Plugin1，原先的 AssetManager 只能加载 HostApp 的资源不能加载 Plugin1 的资源。由此产生出多种解决方案。

**方案1**

进入 Plugin1，则加载 Plugin1 的资源，反射调用 AssetManager 的 addAssetPath 方法，参数是 Plugin1.apk 的路径。同理，从 Plugin1 回到 HostApp，或者进入另一个插件 Plugin2，也要切换资源。每次进入或离开插件，都要切换资源，是一件很繁琐的事情。

**方案2**

 事先把 HostApp 的资源及所有插件资源，都通过 AssetManager 的 addAssetPath 方法添加到一个全局变量中。

在插件 Activity 的基类中，重写 Activity 的 getResource 方法，从这个全局变量中提取资源，这样每个插件 Activity 还像往常一样去编写代码获取资源，并不知道底层框架其实是从全局变量中查找资源。

针对上面的方案2，宿主和所有插件的资源都合并在一起，那么资源的 id 就会发生冲突，由此产生多种解决方案：

1）修改 AAPT，为每个插件的 id 指定不同的前缀，比如 0x71 和 0x72，只要不是 0x7f 这个默认的就行。

2）修改 resources.arsc。在 AAPT 执行后，生成了 R.java 和 resources.arsc。那么就把插件 Plugin1 的 R.java 中所有的资源前缀都改为 0x71，把 resource.arsc 中的 0x7f 也改为 0x71。

3）通过 public.xml 固定 plugin1 中所有的资源。这种方案实现起来不现实，针对固定一个资源的 id 还是很好的解决方案。



## Fragment 是哪门哪派

我曾经一度困惑 Fragment 与 Activity 的区别。二者最大的区别就是 Activity 的一举一动要和 AMS 进行交互，而 Fragment 不用。

之所以会有四大组件的称呼，是因为它们都要在 AndroidManifest 中声明，它们的生命周期函数要和 AMS 进行交互；而 Fragment 只是寄生在 Activity 中的一个“自定义 View”。

正因为 Fragment 不需要和 AMS 打交道，也不用事先在 AndroidManifest 中声明，所以有一种插件化解决方案，即整个 App 只有一个 Activity，每个页面都是用 Fragment 写的，页面切换并不会导致 Activity 切换，而是在当前 Activity 中切换不同的 Fragment。这些 Fragment 可以位于 HostApp 中，也可以位于插件中，只要使用合适的 ClassLoader 加载插件中的类，使用合适的 AssetManager 加载插件中的资源，就是一个完美的解决方案。



## Service、ContentProvider、BroadcastReceiver 插件化的通用解决方案

因为 App 中的 Service、ContentProvider、Receiver 的数量并不多，在插件化中也不会动态新增一个组件，所以最简单的插件化解决方案是：在 HostApp 的 AndroidManifest 文件中事先声明插件中的 Service、ContentProvider、BroadcastReceiver。



## 特定于 Service 的插件化解决方案

如果不事先在宿主 App 中声明插件的 Service，那么 Service 也有其自己的插件解决方案：

1）动态代理。也是欺上瞒下的思路。Service 不同于 Activity，一个 StubActivity 可以对应多个插件 Activity，但是 StubActivity 和插件 Service，只能是一一对应，所以要事先在 HostApp 的 AndroidManifest 中声明多个 StubService，分别对应不同的插件 Service。

2）静态代理，牵线木偶的思想。创建一个 ProxyService，由 ProxyService 来启动插件中的 Service。ProxyService 有分发的思想。缺点是，插件中有几个 Service，HostApp 的 AndroidManifest 中就要声明相同数量的 ProxyService。

3）能否在 HostApp 的 AndroidManifest 中只声明一个 StubService？这就需要使用到分发技术了。把前面介绍过的动态代理与静态替换两种思想相结合。



## 特定于 BroadcastReceiver 的插件化解决方案

BroadcastReceiver 就是一个类。它的插件话解决方案是把静态 Receiver 转换为动态 Receiver。

如果不事先在宿主 App 中声明插件的 BroadcastReceiver，那么 BroadcastReceiver 也有其自己的插件解决方案：

1）动态替换。把插件中的静态 Receiver 都注册为 HostApp 中的动态 Receiver。

2）结合前两种解决方案的思路，StubReceiver 预先占位，同时把插件中的所有的静态 Receiver 都注册为动态 Receiver，这就可以由 StubReceiver 来进行分发。

3）静态代理。仍然是牵线木偶的思想，HostApp 中有一个 ProxyReceiver，由它来分发到具体的插件中的某个 Receiver。这是一对多的关系。



## 特定于 ContentProvider 的插件化解决方案

如果不事先在宿主 App 中声明插件的 ContentProvider，那么 ContentProvider 也有其自己的插件解决方案，那就是动态替换 -- 仍然是占位的思想，在 HostApp 中有一个 StubContentProvider 来“欺骗” AMS，而实际执行的是插件中的 ContentProvider。

但在这里 StubContentProvider 还扮演一个重要的角色，它解析把外部传递进来的 URI，然后分发到具体某个插件的 ContentProvider 中。