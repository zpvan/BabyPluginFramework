

# 获取插件的资源（初级）

1. 创建AssetManager对象并调用addAssetPath方法来加载pluginApkFile。

2. 再创建Resources对象来包装assetManager，通过调用resources.getString(R.string.XXX)来获取插件的资源。

```kotlin
// HostApk的代码
fun loadPluginResources(context: Context, pluginApkFile: File): Resources {
    try {
        val assetManager = AssetManager::class.java.newInstance()
        val addAssetPathMethod = AssetManager::class.java.getDeclaredMethod("addAssetPath", String::class.java)
        addAssetPathMethod.isAccessible = true

        // !!!添加host的资源!!!
        addAssetPathMethod.invoke(assetManager, context.packageResourcePath)
        // !!!添加plugin的资源!!!
        addAssetPathMethod.invoke(assetManager, pluginApkFile.absolutePath)

        // 创建插件 Resources 对象
        return Resources(
            assetManager,
            context.resources.displayMetrics,
            context.resources.configuration
        )
    } catch (e: Exception) {
        Log.e(TAG, "Failed to load plugin resources", e)
        throw RuntimeException("Failed to load plugin resources", e)
    }
}

// 造一个"超级"Resources保存在全局变量中
IPlugin.bigResources = loadPluginResources(context, pluginApkFile)

// PluginLibrary的代码
package com.knox.pluginlibrary

interface IPlugin {
    companion object {
        var bigResources : Resources? = null
    }
}

// PluginApk的代码
package com.knox.pluginapk

class TestActivity1 : AppCompatActivity() {
  
    override fun getResources(): Resources {
        return IPlugin.bigResources ?: super.getResources()
    }
}
```



# 资源冲突

获取插件资源的初级方法，只解决了插件中的资源的加载问题，插件App中的Activity才能正常工作，否则就会抛出资源找不到的异常。

每个资源都有一个对应的id值，比如0x7f001002，由于宿主App和插件App都是各自打包，所以宿主App中的某个资源的id值极有可能和插件App中某个资源的id值是相同的，那我们就加载不到正确的资源了。



# App打包流程

## 阶段1

（1）Task :app:compileDebugAidl
aidl 把项目中自定义的 aidl 文件生成相应的 Java Interface 代码文件。Android Studio 会在我们编写一个 aidl 文件后自动执行。

（2）Task :app:generateDebugBuildConfig
根据 build.gradle 里面配置的内容生成相应的 java 代码或者 res 代码。

（3）Task :app:generateDebugResValues
获取gradle中配置的资源文件

（5）Task :app:mergeDebugAssets
          Task :app:mergeDebugAssets
          Task :app:processDebugManifest
合并 res 资源文件，assets 文件，manifest 文件。

（6）Task :app:processDebugResources
aapt 为 res 目录下的资源生成 R.java 文件。Android Studio 会在我们编写一个 xml 文件后自动执行。

## 阶段2

（1）Task :app:compileDebugKotlin
kotlin 文件编译成 class 文件。

（2）Task :app:compileDebugJavaWithJavac
javac 编译 java 文件生成 class 文件。

## 阶段3

（1）Task :app:dexBuilderDebug
dx 把所有的 class 文件（包括第三方库的 class 文件）转换为 dex 文件。

> `D8`就是用来代替dx用来进行转换class文件的，它的优势在于：编译更快、更小的dex文件、更好的性能。
>
> 而`R8`工具是用来替代ProGuard的，用于代码的压缩和混淆。

## 阶段4

（1）Task :app:packageDebug
apkbuilder/zipflinger（生成APK包）将 `manifest` 文件、`resources` 文件、`dex` 文件、`assets` 文件等等打包成一个压缩包，也就是未签名的apk文件。

## 阶段5

（1）签名和对齐。

zipalign 对要发布的 apk 文件进行对齐操作，以便在运行时节省内存。

- 如果使用的是 `apksigner`，只能在为 APK 文件签名之前执行 zipalign。
- 如果使用的是 `jarsigner`，只能在为 APK 文件签名之后执行 zipalign。



# 资源id冲突的解决方案（中级）

方法1：重写 AAPT 命令，在插件 apk 打包打包过程中，通过指定资源 id 的前缀，比如 0x71，来保证宿主和插件的资源 id 永远不会冲突。



方法2：在插件 apk 打包后，修改 R.java 和 resources.arse 中存储的资源 id 值，比如默认的 0x7f 前缀，修改为 0x71，这样就保证了宿主和插件的资源 id 永远不会冲突。

## 自定义 Gradle 插件

small-gradle 是一个自定义 Gradle 插件，它通过修改 App 的打包流程，在这个过程中修改资源 id 的前缀。



方法3：在 public.xml 中指定的 apk 中所有资源的 id 值。但这样做是很麻烦的，每增加一个资源，都要维护 public.xml，不可维护。







# 资源id冲突的解决方案（高级）

如果不事先合并资源，那就为每个插件创建一个 AssetManager，每个 AssetManager 都是通过反射调用 addAssetPath 方法，把插件自己的资源添加进去，从而，当从宿主进入一个插件的时候，就把 AssetManager 切换为插件的 AssetManager；反之，当从插件回到宿主的时候，再把 AssetManager 切换回宿主的 AssetManager。